# 简介

干就完了。

# 已知问题

- 在第一次进行游戏的时候分数显示似乎有一点问题

# 经验记录

实现的过程中遇到了不少的问题，在这记录一下。

## 实现动画的过程

为了实现动画付出的努力还是比较多的，在一开始，我使用一个简单的二维数组来存储游戏进行时的模型。

```flutter
List<List<int>> model = [];
```

然后在Render过程中通过循环渲染和栅格布局来实现2048可操作界面的展示。

在这个阶段，我可以直接使用Model对View进行渲染，从而得到想要的效果。

我一开始认为Flutter的布局设计应该跟React Native相差不大，只需要在Container里追加一行声明布局的代码就可以对布局进行调整，正是这个错误的小想法，让我在实现程序的过程中进行了许多不必要的重构。

在Flutter中，绝对布局的组件需要放在Stack组件下，因此无法使用栅格布局作为它们的默认位置，为了让它们能够找到自己正确的位置，我需要通过传入参数来控制它们在Stack中的坐标。

同时，2048在移动时会不停有item产生和消失（或者说是合并），我需要通过循环渲染中的Key来告诉Flutter，哪些item是应该保留的，哪些item是应该删掉的，哪些item是用户进行操作后新增的。

基于这些需求，上面构建的简单的整型二维数组就不够用了，我需要构建一个新的模型，来实现这些复杂的功能。

```flutter
class ItemModel {
  int val; // 值
  GlobalKey itemKey = GlobalKey(); // Key
  Offset offset; // 相对坐标
  ItemModel({this.val = 0, this.offset = Offset.zero}); // 构造函数
}
```

于是，我新建了一个这样的模型来表示item，它拥有实现动画该有的所有属性。

现在整个游戏的模型就应该是：

```flutter
List<List<ItemModel>> model = [];
```

现在，通过操作model，我就可以实现我想要的动画了，但它现在就不再是一个纯数据模型，而是一个介于Model和View之间的中间件。

这个变化导致我在之后想要实现Undo功能的时候遇到了一点麻烦，但Undo功能里最大的麻烦却并不是由它产生的。

## Undo功能的实现

如果将动画从2048里剥离出来，就会发现2048其实是一个非常适合用状态机实现的游戏。

因为它的核心数据切片非常小，仅需16个数字就能表示。这使得我们在进行游戏的过程中可以非常方便的存储它在某一时间段的状态，并在需要的时候将这些存储的数据还原到程序中。

因为我认为2048的历史状态数据不会特别大，所以在还没有实现动画的时候，我使用一个三维数组来存储用户的操作信息（实际上是把它当作栈使用的）。

```flutter
List<List<List<int>>> history = [];

// 写入历史
void pushIntoHistory(List<List<int>> model) {
  history.add(model)
}

// 读出历史
List<List<int>> popFromHistory() {
  return history.removeAt(history.length - 1);
}
```

在实现动画以后，因为Model的结构发生了变化，我新增了一个方法来获取model中的纯数据。

```flutter
List<List<int>> getPureDataFromData(List<List<ItemModel>> model) {
  List<List<int>> result = [];
  for (int i = 0; i < model.length; i++) {
    List<int> row = [];
    for (int j = 0; j < model[i].length; j++) {
      row.add(model[i][j].val);
    }
    result.add(row);
  }
  return result;
}
```

通过这种方法获取纯数据以后，就可以通过上面的方法对历史状态进行写入和弹出了。

通过这种方式编写出来的程序在模拟器和安卓机（骁龙765G平台，6G内存）上运行时都没有什么大问题，但在我的iPhone XR上运行的时候，动画却没有办法跑慢60帧。

我对比了一下XR和安卓机的硬件配置，首先排除了CPU的问题，那引发卡顿的原因多半就是内存的问题了。

因为XR的内存只有3GB，在使用数组这种需要长连续内存的结构时确实可能碰到内存瓶颈，于是后面我改用链表结构实现了History的结构，虽然动画的表现好转了不少，但还是有着能感知到的卡顿。

最终我的解决办法是使用sqlite取代内存存储状态信息，通过将内存的压力转移到CPU和硬盘上解决了ios上内存不足的问题，从而在恢复了流畅动画的同时保留了从开局到结束游戏时的Undo能力。

## 重启游戏时恢复上一次游玩时的状态

最初发现这个问题是在退出游戏并重新进入后发现游戏的状态完全丢失了，才想到应该有一个存储游戏进度的功能。

一开始解决这个问题是通过文件系统，通过将关键数据转换为JSON格式在本地进行读写来实现游玩状态的保存和恢复。

后面在解决Undo和动画的过程中将状态存储移动到了Sqlite数据库，于是这个功能也交由数据库进行实现了。
